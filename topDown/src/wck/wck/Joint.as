package wck {		import Box2DAS.*;	import Box2DAS.Collision.*;	import Box2DAS.Collision.Shapes.*;	import Box2DAS.Common.*;	import Box2DAS.Dynamics.*;	import Box2DAS.Dynamics.Contacts.*;	import Box2DAS.Dynamics.Joints.*;	import cmodule.Box2D.*;	import wck.*;	import misc.*;	import flash.utils.*;	import flash.events.*;	import flash.display.*;	import flash.text.*;	import flash.geom.*;	import flash.ui.*;		/**	 * Wraps every Box2d joint type.	 */	public class Joint extends ScrollerChild {				/// See the Box2d documentation on joints for explanation of these variables:						/// collideConnected				[Inspectable(defaultValue=false)]		public function set collideConnected(v:Boolean):void {			if(b2joint) {				b2joint.m_collideConnected = v;			}			else {				_collideConnected = v;			}		}				public function get collideConnected():Boolean {			if(b2joint) {				return b2joint.m_collideConnected;			}			return _collideConnected;		}				public var _collideConnected:Boolean = false;						/// lowerLimit				[Inspectable(defaultValue=0.0)]		public function set lowerLimit(v:Number):void {			if(b2joint) {				b2joint.SetLowerLimit(v);			}			else {				_lowerLimit = v;			}		}				public function get lowerLimit():Number {			if(b2joint) {				return b2joint.GetLowerLimit();			}			else {				return _lowerLimit;			}		}				public var _lowerLimit:Number = 0.0;						/// upperLimit				[Inspectable(defaultValue=0.0)]		public function set upperLimit(v:Number):void {			if(b2joint) {				b2joint.SetUpperLimit(v);			}			else {				_upperLimit = v;			}		}				public function get upperLimit():Number {			if(b2joint) {				return b2joint.GetUpperLimit();			}			else {				return _upperLimit;			}		}				public var _upperLimit:Number = 0.0;						/// maxForce				[Inspectable(defaultValue=0.0)]		public function set maxForce(v:Number):void {			if(b2joint) {				b2joint.SetMaxMotorForce(v);			}			else {				_maxForce = v;			}		}				public function get maxForce():Number {			if(b2joint) {				return b2joint.GetMaxMotorForce();			}			else {				return _maxForce;			}		}				public var _maxForce:Number = 0.0;				/// maxTorque				[Inspectable(defaultValue=0.0)]		public function set maxTorque(v:Number):void {			if(b2joint) {				b2joint.SetMaxMotorTorque(v);			}			else {				_maxTorque = v;			}		}				public function get maxTorque():Number {			if(b2joint) {				return b2joint.GetMaxMotorTorque();			}			else {				return _maxTorque;			}		}				public var _maxTorque:Number = 0.0;								/// motorSpeed				[Inspectable(defaultValue=0.0)]		public function set motorSpeed(v:Number):void {			if(b2joint) {				b2joint.SetMotorSpeed(v);			}			else {				_motorSpeed = v;			}		}				public function get motorSpeed():Number {			if(b2joint) {				return b2joint.GetMotorSpeed();			}			else {				return _motorSpeed;			}		}				public var _motorSpeed:Number = 0.0;						/// enableLimit				[Inspectable(defaultValue=false)]		public function set enableLimit(v:Boolean):void {			if(b2joint) {				b2joint.EnableLimit(v);			}			else {				_enableLimit = v;			}		}				public function get enableLimit():Boolean {			if(b2joint) {				return b2joint.IsLimitEnabled();			}			else {				return _enableLimit;			}		}				public var _enableLimit:Boolean = false;						/// enableMotor				[Inspectable(defaultValue=false)]		public function set enableMotor(v:Boolean):void {			if(b2joint) {				b2joint.EnableMotor(v);			}			else {				_enableMotor = v;			}		}				public function get enableMotor():Boolean {			if(b2joint) {				return b2joint.IsMotorEnabled();			}			else {				return _enableMotor;			}		}				public var _enableMotor:Boolean = false;						/// type				[Inspectable(defaultValue='None',enumeration='None,Distance,Line,Mouse,Prismatic,Pulley,Revolute,Weld,Friction,Rope')]		public var type:String = 'None';						/// axisX				[Inspectable(defaultValue=0)]		public var axisX:Number = 0;						/// axisY				[Inspectable(defaultValue=0)]		public var axisY:Number = 0;						/// spring						[Inspectable(defaultValue=false)]		public function set spring(v:Boolean):void {			if(v == _spring) {				return;			}			_spring = v;			if(b2joint) {				if(_spring) {					createSpring();				}				else {					destroySpring();				}			}		}				public function get spring():Boolean {			return _spring;		}				public var _spring:Boolean = false;						/// springConstant				[Inspectable(defaultValue=0.0)]		public var springConstant:Number = 0.0;						/// springDamping				[Inspectable(defaultValue=0.0)]		public var springDamping:Number = 0.0;						/// frequencyHz				[Inspectable(defaultValue=5.0)]		public function set frequencyHz(v:Number):void {			if(b2joint) {				b2joint.SetFrequency(v);			}			else {				_frequencyHz = v;			}		}				public function get frequencyHz():Number {			if(b2joint) {				return b2joint.GetFrequency();			}			else {				return _frequencyHz;			}		}				public var _frequencyHz:Number = 5.0;						/// dampingRatio				[Inspectable(defaultValue=0.7)]		public function set dampingRatio(v:Number):void {			if(b2joint) {				b2joint.SetDampingRatio(v);			}			else {				_dampingRatio = v;			}		}				public function get dampingRatio():Number {			if(b2joint) {				return b2joint.GetDampingRatio();			}			else {				return _dampingRatio;			}		}				public var _dampingRatio:Number = 0.7;						/// pulleyGearRatio				[Inspectable(defaultValue=1.0)]		public var pulleyGearRatio:Number = 1.0;		[Inspectable(defaultValue='')]		public var target1Name:String = '';		[Inspectable(defaultValue='')]		public var target2Name:String = '';		[Inspectable(defaultValue='')]		public var pulleyGearPartnerName:String = '';							/// gearCollideConnected				[Inspectable(defaultValue=false)]		public function set gearCollideConnected(v:Boolean):void {			if(b2gear) {				b2gear.m_collideConnected = v;			}			else {				_gearCollideConnected = v;			}		}				public function get gearCollideConnected():Boolean {			if(b2gear) {				return b2gear.m_collideConnected;			}			else {				return _gearCollideConnected;			}		}				public var _gearCollideConnected:Boolean = false;				[Inspectable(defaultValue='')]		public var connectorClassName:String = '';				[Inspectable(defaultValue=2)]		public var connectorThickness:Number = 2;				[Inspectable(defaultValue='#888888',type='Color')]		public var connectorColor:uint = 0x888888;				/// Mouse joints only - the position of the mouse joint will be passed to "SetTarget" each frame. This allows		/// mouse joints to be animated in flash via tweens.		[Inspectable(defaultValue=false)]		public var tweened:Boolean = false;				public var world:wck.World;		public var b2joint:b2Joint;		public var target1Object:DisplayObject;		public var bodyShape1:BodyShape;		public var b2body1:b2Body;		public var target2Object:DisplayObject;		public var target2Joint:Joint;		public var bodyShape2:BodyShape;		public var b2body2:b2Body;		public var pulleyGearPartner:Joint;		public var b2gear:b2Joint;		public var anchorPoint:Point;		public var connector:Connector;				/**		 *		 */		public override function create():void {			locateBodies();			createAnchorPoint();			createJoint();			createConnector();			if(_spring) {				createSpring();			}			super.create();		}				/**		 *		 */		public override function destroy():void {			if(world && world.created && !world.disabled && world.parent) { /// Don't do anything if the world is being destroyed.				destroyConnector();				destroyGearJoint();				destroyJoint();				if(_spring) {					destroySpring();				}			}		}						/**		 * This function determines what bodies should be involved in a joint.		 */		public function locateBodies():void {			world = Util.findAncestorOfClass(this, wck.World) as wck.World;			world.ensureCreated();			var exclude:Array = [];			var autoFind:uint = 0;			target1Object ||= bodyShape1;			if(!target1Object && target1Name) {				target1Object = Util.getDisplayObjectByPath(this.parent, target1Name, world);				bodyShape1 = target1Object as BodyShape;			}			if(bodyShape1) {				exclude.push(bodyShape1);			}			else {				autoFind = 1;			}			if(type != 'Mouse') { /// Mouse joints always have only one body shape (the other is ground).				target2Object ||= bodyShape2;				if(!target2Object && target2Name) {					target2Object = Util.getDisplayObjectByPath(this.parent, target2Name, world);					bodyShape2 = target2Object as BodyShape;					target2Joint = target2Object as Joint;				}				else if(!bodyShape2 && !target2Joint) {					++autoFind;				}			}			if(autoFind > 0) {				var objs:Array = Util.getObjectsUnderPointByClass(world, localToGlobal(new Point(0, 0)), BodyShape, autoFind, exclude);				for(var i:int = 0; i < objs.length; ++i) {					if(bodyShape1) {						bodyShape2 = objs[i];						target2Object = bodyShape2;					}					else {						bodyShape1 = objs[i];						target1Object = bodyShape1;					}				}			}			if(bodyShape1) {				bodyShape1.ensureCreated();				b2body1 = bodyShape1.b2body;			}			else {				b2body1 = world.b2world.m_groundBody;			}			if(target2Joint) {				target2Joint.ensureCreated();				bodyShape2 = target2Joint.bodyShape1;			}			if(bodyShape2) {				bodyShape2.ensureCreated();				b2body2 = bodyShape2.b2body;			}			else {				b2body2 = world.b2world.m_groundBody;			}			if(!target2Object) {				target2Object = this;			}			if(!pulleyGearPartner && pulleyGearPartnerName) {				pulleyGearPartner = Util.getDisplayObjectByPath(this.parent, pulleyGearPartnerName, world) as Joint;			}			if(pulleyGearPartner) {				pulleyGearPartner.ensureCreated();			}						/// When object this joint depends on (targets) are removed, also remove this joint.			if(target1Object) {				listenWhileVisible(target1Object, Event.REMOVED_FROM_STAGE, handleTargetRemoved);			}			if(target2Object) {				listenWhileVisible(target2Object, Event.REMOVED_FROM_STAGE, handleTargetRemoved);			}			if(pulleyGearPartner) {				listenWhileVisible(pulleyGearPartner, Event.REMOVED_FROM_STAGE, handleTargetRemoved);				if(pulleyGearPartner.target2Object) {					listenWhileVisible(pulleyGearPartner.target2Object, Event.REMOVED_FROM_STAGE, handleTargetRemoved);				}			}		}				/**		 * Some object this joint depends on has been removed / destroyed!		 */		public function handleTargetRemoved(e:Event):void {			if(world && world.created) { /// Don't do anything if the world is being destroyed.				if(e.target == target1Object) {					remove();				}				else if(e.target == target2Object) {					destroyJoint();					destroyGearJoint();					destroyConnector();					if(type == 'Pulley') {						pulleyGearPartner.destroyConnector();					}				}				else if(e.target == pulleyGearPartner || (pulleyGearPartner && e.target == pulleyGearPartner.target2Object)) {					if(type == 'Pulley') {						destroyJoint();												destroyConnector();					}					else {						destroyGearJoint();					}				}			}		}				/**		 * Just dispatches to the appropriate joint creation function.		 */		public function createJoint():void {			if(b2body1 == b2body2) {				return;			}			switch(type) {				case 'Distance':					createDistanceJoint();					break;				case 'Line':					createLineJoint();					break;				case 'Mouse':					createMouseJoint();					break;				case 'Prismatic':					createPrismaticJoint();					if(pulleyGearPartner) {						createGearJoint();					}					break;				case 'Pulley':					createPulleyJoint();					break;				case 'Revolute':					createRevoluteJoint();					if(pulleyGearPartner) {						createGearJoint();					}					break;				case 'Weld':					createWeldJoint();					break;				case 'Friction':					createFrictionJoint();					break;				case 'Rope':					createRopeJoint();					break;			}			if(b2joint) {				listenWhileVisible(this, GoodbyeJointEvent.GOODBYE_JOINT, handleGoodbyeJoint);			}		}				/**		 * 		 */		public function handleGoodbyeJoint(e:GoodbyeJointEvent):void {			if(e.joint == b2joint) {				b2joint = null;			}			else if(e.joint == b2gear) {				b2gear = null;			}		}				/**		 *		 */		public function createAnchorPoint():void {			if(target1Object) {				anchorPoint = Util.localizePoint(target1Object, this);				if(!tweened) {					listenWhileVisible(world, StepEvent.STEP, updateAnchorPoint, false, -20);				}			}		}				/**		 *		 */		public function updateAnchorPoint(e:Event):void {			var p:Point = Util.localizePoint(parent, target1Object, anchorPoint);			x = p.x;			y = p.y;		}				/**		 * Destroy the b2Joint.		 */		public function destroyJoint():void {			if(b2joint) {				world.doOutsideTimeStep(function():void {					if(b2joint) {						b2joint.destroy();						b2joint = null;					};				});			}		}				/**		 * Destroy the gear joint.		 */		public function destroyGearJoint():void {			if(b2gear) {				world.doOutsideTimeStep(function():void {					if(b2gear) {						b2gear.destroy();						b2gear = null;					}				});			}		}				/**		 * Initialize shared joint definition properties.		 */		public function initJointDef(jd:b2JointDef):void {			jd.collideConnected = _collideConnected;			jd.userData = this;		}				/**		 * Create a distance joint.		 */		public function createDistanceJoint():void {			initJointDef(b2Def.distanceJoint);			b2Def.distanceJoint.frequencyHz = _frequencyHz;			b2Def.distanceJoint.dampingRatio = _dampingRatio;			var wp1:Point = Util.localizePoint(world, this);			var wp2:Point = Util.localizePoint(world, target2Object);			b2Def.distanceJoint.Initialize(b2body1, b2body2, new V2(wp1.x / world.scale, wp1.y / world.scale), new V2(wp2.x / world.scale, wp2.y / world.scale));			b2joint = new b2DistanceJoint(world.b2world, b2Def.distanceJoint, this);		}				/**		 * Creates a line joint.		 */		public function createLineJoint():void {			initJointDef(b2Def.lineJoint);			b2Def.lineJoint.enableMotor = _enableMotor;			b2Def.lineJoint.maxMotorTorque = _maxTorque;			b2Def.lineJoint.motorSpeed = _motorSpeed;			b2Def.lineJoint.frequencyHz = _frequencyHz;			b2Def.lineJoint.dampingRatio = _dampingRatio;			var wp1:Point = Util.localizePoint(world, this);			var axis:V2;			var wp2:Point = Util.localizePoint(world, target2Object);			if(axisX == 0 && axisY == 0) {				axis = new V2(wp2.x - wp1.x, wp2.y - wp1.y);			}			else {				axis = new V2(axisX, axisY);			}			axis.normalize();			b2Def.lineJoint.Initialize(b2body1, b2body2, new V2(wp2.x / world.scale, wp2.y / world.scale), axis);			b2joint = new b2LineJoint(world.b2world, b2Def.lineJoint, this);		}				/**		 * Create a mouse joint.		 */		public function createMouseJoint():void {			initJointDef(b2Def.mouseJoint);			b2Def.mouseJoint.frequencyHz = _frequencyHz;			b2Def.mouseJoint.dampingRatio = _dampingRatio;			b2Def.mouseJoint.maxForce = _maxForce;			b2Def.mouseJoint.Initialize(b2body1, V2.fromP(Util.localizePoint(world, this)).divideN(world.scale));			b2joint = new b2MouseJoint(world.b2world, b2Def.mouseJoint, this);			if(tweened) {				listenWhileVisible(world, StepEvent.STEP, updateMouseJointTarget, false, 1);			}		}				/**		 *		 */		public function updateMouseJointTarget(e:Event):void {			(b2joint as b2MouseJoint).SetTarget(V2.fromP(Util.localizePoint(world, this)).divideN(world.scale));		}				/**		 * Create a prismatic joint.		 */		public function createPrismaticJoint():void {			initJointDef(b2Def.prismaticJoint);			b2Def.prismaticJoint.enableLimit = _enableLimit;			b2Def.prismaticJoint.lowerTranslation = _lowerLimit;			b2Def.prismaticJoint.upperTranslation = _upperLimit;			b2Def.prismaticJoint.enableMotor = _enableMotor;			b2Def.prismaticJoint.maxMotorForce = _maxForce;			b2Def.prismaticJoint.motorSpeed = _motorSpeed;			var wp1:Point = Util.localizePoint(world, this);			var axis:V2;			if(axisX == 0 && axisY == 0) {				var wp2:Point = Util.localizePoint(world, target2Object);				axis = new V2(wp2.x - wp1.x, wp2.y - wp1.y);			}			else {				axis = new V2(axisX, axisY);			}			axis.normalize();			if(!b2body1.IsStatic() && b2body2.IsStatic()) { /// Make sure gears have a static body as body1				var flip:b2Body = b2body1;				b2body1 = b2body2;				b2body2 = flip;			}			b2Def.prismaticJoint.Initialize(b2body1, b2body2, new V2(wp1.x / world.scale, wp1.y / world.scale), axis);			b2joint = new b2PrismaticJoint(world.b2world, b2Def.prismaticJoint, this);					}				/**		 * Creates a pulley joint.		 */		public function createPulleyJoint():void {			initJointDef(b2Def.pulleyJoint);			b2Def.pulleyJoint.maxLengthA = _lowerLimit;			b2Def.pulleyJoint.maxLengthB = _upperLimit;			b2Def.pulleyJoint.ratio = pulleyGearRatio;			var wp1:Point = Util.localizePoint(world, this);			var wp2:Point = Util.localizePoint(world, pulleyGearPartner);			var gp1:Point = Util.localizePoint(world, target2Object);			var gp2:Point = Util.localizePoint(world, pulleyGearPartner.target2Object);			b2Def.pulleyJoint.Initialize(				b2body1, 				pulleyGearPartner.b2body1,				new V2(gp1.x / world.scale, gp1.y / world.scale),				new V2(gp2.x / world.scale, gp2.y / world.scale),				new V2(wp1.x / world.scale, wp1.y / world.scale),				new V2(wp2.x / world.scale, wp2.y / world.scale),				pulleyGearRatio);			b2joint = new b2PulleyJoint(world.b2world, b2Def.pulleyJoint, this);		}				/**		 * Create a revolute joint.		 */		public function createRevoluteJoint():void {			initJointDef(b2Def.revoluteJoint);			b2Def.revoluteJoint.enableLimit = _enableLimit;			b2Def.revoluteJoint.lowerAngle = _lowerLimit;			b2Def.revoluteJoint.upperAngle = _upperLimit;			b2Def.revoluteJoint.enableMotor = _enableMotor;			b2Def.revoluteJoint.maxMotorTorque = _maxTorque;			b2Def.revoluteJoint.motorSpeed = _motorSpeed;			var wp1:Point = Util.localizePoint(world, this);			if(!b2body1.IsStatic() && b2body2.IsStatic()) { /// Make sure gears have a static body as body1				var flip:b2Body = b2body1;				b2body1 = b2body2;				b2body2 = flip;			}			b2Def.revoluteJoint.Initialize(b2body1, b2body2, new V2(wp1.x / world.scale, wp1.y / world.scale));			b2joint = new b2RevoluteJoint(world.b2world, b2Def.revoluteJoint, this);		}				/**		 * Create a weld joint.		 */		public function createWeldJoint():void {			initJointDef(b2Def.weldJoint);			var wp1:Point = Util.localizePoint(world, this);			b2Def.weldJoint.Initialize(b2body1, b2body2, new V2(wp1.x / world.scale, wp1.y / world.scale));			b2joint = new b2WeldJoint(world.b2world, b2Def.weldJoint, this);		}				/**		 * Create a friction joint.		 */		public function createFrictionJoint():void {			initJointDef(b2Def.frictionJoint);			b2Def.frictionJoint.maxForce = _maxForce;			b2Def.frictionJoint.maxTorque = _maxTorque;			var wp1:Point = Util.localizePoint(world, this);			b2Def.frictionJoint.Initialize(b2body1, b2body2, new V2(wp1.x / world.scale, wp1.y / world.scale));			b2joint = new b2FrictionJoint(world.b2world, b2Def.frictionJoint, this);		}				/**		 * Creates a gear joint.		 */		public function createGearJoint():void {			initJointDef(b2Def.gearJoint);			b2Def.gearJoint.collideConnected = _gearCollideConnected;			b2Def.gearJoint.Initialize(b2joint, pulleyGearPartner.b2joint, pulleyGearRatio);			b2gear = new b2GearJoint(world.b2world, b2Def.gearJoint, this);		}				/**		 * Create a rope joint.		 */		public function createRopeJoint():void {			initJointDef(b2Def.ropeJoint);			var wp1:Point = Util.localizePoint(world, this);			var wp2:Point = Util.localizePoint(world, target2Object);			b2Def.ropeJoint.Initialize(b2body1, b2body2, new V2(wp1.x / world.scale, wp1.y / world.scale), new V2(wp2.x / world.scale, wp2.y / world.scale));			if(_upperLimit != 0) {				b2Def.ropeJoint.maxLength = _upperLimit;			}			b2joint = new b2RopeJoint(world.b2world, b2Def.ropeJoint, this);		}				/**		 * Create a connector object between the joint and the target2Object.		 */		public function createConnector():void {			if(target2Object && connectorClassName != '') {				var connectorClass:Class = getDefinitionByName(connectorClassName) as Class;				connector = new connectorClass() as Connector;				connector.from = this;				connector.to = target2Object;				var cl:ConnectorLine = connector as ConnectorLine;				if(cl) {					cl.color = connectorColor;					cl.thickness = connectorThickness;				}				world.addChild(connector);			}		}				/**		 * Destroy the connector.		 */		public function destroyConnector():void {			if(connector) {				Util.remove(connector);				connector = null;			}		}				/** 		 * Make the joint act as a spring. Only works for motor-enabled joints.		 */		public function createSpring():void {			listenWhileVisible(world,StepEvent.STEP, updateSpring);		}				/**		 * Update the joint to act as a spring.		 */		public function updateSpring(e:Event):void {			var pj:b2PrismaticJoint = b2joint as b2PrismaticJoint;			var lj:b2LineJoint = b2joint as b2LineJoint;			var rj:b2RevoluteJoint = b2joint as b2RevoluteJoint			if(pj) {				var pjt:Number = pj.GetJointTranslation();				pj.SetMaxMotorForce(Math.abs((pjt * springConstant) + (pj.GetJointSpeed() * springDamping)));				pj.SetMotorSpeed(pjt > 0 ? -100000 : +100000);			}			else if(rj) {				var rja:Number = rj.GetJointAngle();				rj.SetMaxMotorTorque(Math.abs((rja * springConstant) + (rj.GetJointSpeed() * springDamping)));				rj.SetMotorSpeed(rja > 0 ? -100000 : +100000);			}			else if(lj) {				var ljt:Number = lj.GetJointTranslation();				lj.SetMaxMotorForce(Math.abs((ljt * springConstant) + (lj.GetJointSpeed() * springDamping)));				lj.SetMotorSpeed(ljt > 0 ? -100000 : +100000);			}		}				/**		 * Stop updating the joint to act as a spring.		 */		public function destroySpring():void {			stopListening(world,StepEvent.STEP, updateSpring);		}	}}