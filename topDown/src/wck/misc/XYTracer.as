package misc {	import misc.*;	import flash.display.*;	import flash.events.*;	import flash.utils.*;	import flash.geom.*;	import flash.events.*;		/**	 * This class will take a stream of points (like from mouse movement) and find the best series of points	 * to simplify that path, based on a tolerance. It will smooth the stroke as points are coming in,	 * so that the simplified path can be constructed before the stroke is finished (smooth in realtime).	 */	public class XYTracer extends EventDispatcher {				/// Event dispatched when a temporary point is added.		public static const TEMP_POINT:String = 'onTempPoint';				/// Event dispatched when a permanent point is added.		public static const PERM_POINT:String = 'onPermPoint';				/// Event dispatched when the stroke is complete.		public static const FINISHED:String = 'onFinished';				/// The tolerance for change in the stroke. Lower numbers will result in a "tighter" path. Higher numbers		/// will result in less points.		public var tolerance:Number = 10;				/// Should this stroke loop?		public var loop:Boolean = false;				/// Usually, the last point added always becomes a permanent point. For looped strokes, this		/// can be problematic since the first and last point may be very close. So if the distance between		/// the first and last point are less than loopTolerance, don't add the "final" point.		public var loopTolerance:Number = 20;				/// Points of the permanent, simplified stroke path.		public var points:Array = [];				/// Temporary points that have not been simplified yet.		public var tempPoints:Array = [];				/// The center of the permanent points.		public var center:Point = new Point();				/// If the final points are all within this distance from the center, the stroke will		/// be considered circular.		public var circleTolerance:Number = 10;				/// Is the stoke circlular? This is set after "finish" is called.		public var circle:Boolean;				/// The average distance of points to the center - only calculated on finish.		public var circleRadius:Number = 0;				/// Track the points in the coordinate space of this object (should be on the stage).		public var localTo:DisplayObject;				/// A coordinate source.		public var source:XYSource;				public function XYTracer(s:XYSource = null, priority:Number = 5):void {			if(s) {				source = s;				Input.stage.addEventListener(Event.ENTER_FRAME, sourceUpdate, false, priority, true); /// Weak ref.			}		}				/**		 * Add a point from the XYSource.		 */		public function sourceUpdate(e:Event):void {			addPoint(source.point);		}				/**		 * Add a new point to the stroke. If a permanent point is aded, return it.		 */		public function addPoint(newP:Point, localize:Boolean = true):Point {			if(localTo && localize) {				newP = localTo.globalToLocal(newP);			}			/// First point? just add it to the points array.			if(points.length == 0) {				points.push(newP);				dispatchEvent(new Event(PERM_POINT));				center.x = newP.x;				center.y = newP.y;				return newP;			}			/// If the last point is the same as the one being added, dont do anything.			var lastP:Point = (tempPoints.length > 0) ? tempPoints[tempPoints.length - 1] : points[points.length - 1];			if(lastP.x == newP.x && lastP.y == newP.y) {				return null;			}			/// Loop through the temporary points and find the best "breaking" point.			var firstP:Point = points[points.length - 1];			var diffP:Point = newP.subtract(firstP);			var len:Number = diffP.length;			var breakPoint:Point = null;			var diff:Number = 0;			var breakIndex:int = 0;			for(var i:int = 1; i < tempPoints.length; ++i) {				var nextP:Point = tempPoints[i];				var crossP:Point = firstP.subtract(nextP);				var newDiff:Number = Math.abs((diffP.x * crossP.y - diffP.y * crossP.x) / len);				if(newDiff > diff) {					breakPoint = nextP;					diff = newDiff;					breakIndex = i;				}			}			/// If the change at the chosen point is greater than the tolerance, add it to the final			/// points array and discard all temporary points up to that one.			if(diff > tolerance) {				tempPoints = tempPoints.slice(breakIndex + 1);				/// Weighted average so we don't have to completely recalculate the center.				center.x = (center.x * points.length + breakPoint.x) / (points.length + 1);				center.y = (center.y * points.length + breakPoint.y) / (points.length + 1);				points.push(breakPoint);				dispatchEvent(new Event(PERM_POINT));				return breakPoint;			}			else {				/// Otherwise just push the new point onto the pile.				tempPoints.push(newP);				dispatchEvent(new Event(TEMP_POINT));				return null;			}		}				/** 		 * Add the last point to the final point array to complete the stroke. Return the last		 * point if it is added, or null if already has been added.		 */		public function finish():Point {			/// Stop listening to the coordinate source.			if(source) {				Input.stage.removeEventListener(Event.ENTER_FRAME, sourceUpdate);			}			/// Add the last temporary point to close the path. On loops try to snap to the first point.			var p:Point = tempPoints[tempPoints.length - 1];			var returnP:Point = null;			if(p && (!loop || Point.distance(points[0], p) > loopTolerance)) {				returnP = p;				/// Weighted average so we don't have to completely recalculate the center.				center.x = (center.x * points.length + p.x) / (points.length + 1);				center.y = (center.y * points.length + p.y) / (points.length + 1);								tempPoints = [];				points.push(p);				dispatchEvent(new Event(PERM_POINT));			}			/// Test for circularity. Note: 1 point = circular. 2 point = circular if very small.			circle = true;			var distances:Array = [];			circleRadius = 0;			for(var i:int = 0; i < points.length; ++i) {				distances.push(Point.distance(points[i], center));				circleRadius += distances[i];			}			circleRadius /= points.length;			for(i = 0; i < points.length; ++i) {				if(Math.abs(circleRadius - distances[i]) > circleTolerance) {					circle = false;					break;				}			}			dispatchEvent(new Event(FINISHED));			return returnP;		}				/**		 * Get a graphics path that can be used to draw the permanent and temporary points.		 */		public function get path():GraphicsPath {			var g:GraphicsPath = new GraphicsPath();			if(points.length > 0) {				var p:Point = points[0];				g.moveTo(p.x, p.y);				for(var i:int = 1; i < points.length; ++i) {					p = points[i];					g.lineTo(p.x, p.y);				}				for(i = 0; i < tempPoints.length; ++i) {					p = tempPoints[i];					g.lineTo(p.x, p.y);				}			}			return g;		}	}}