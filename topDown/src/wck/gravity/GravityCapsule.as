package gravity {		import Box2DAS.*;	import Box2DAS.Collision.*;	import Box2DAS.Collision.Shapes.*;	import Box2DAS.Common.*;	import Box2DAS.Dynamics.*;	import Box2DAS.Dynamics.Contacts.*;	import Box2DAS.Dynamics.Joints.*;	import cmodule.Box2D.*;	import wck.*;	import gravity.*;	import misc.*;	import flash.utils.*;	import flash.events.*;	import flash.display.*;	import flash.text.*;	import flash.geom.*;	import flash.ui.*;	/**	 * Provides capsule, or rounded rectangle gravity.	 */	public class GravityCapsule extends GravityRadial {				public var capsule:V2 = new V2(50, 50);				/**		 * Get the rectangular dimentions that define the capsule.		 */		public override function initStep(e:Event):void {			var b:Rectangle = Util.bounds(this);			capsule.xy(b.width / 2, b.height / 2);			//v = V2.rotate(base, rotation * Util.D2R); // Added so rotating can change the gravity direction. NEVERMIND. Buggy.			v = base;		}				/**		 * Calculate the capsule gravity vector from the Box2d world point.		 */		public override function gravity(p:V2, b:b2Body = null, b2:BodyShape = null):V2 {			/// Transform the point into the local coordinate space.			var localP:Point = Util.localizePoint(this, world, V2.multiplyN(p, world.scale).toP());			/// If the point is within the minimum region, just return base gravity.			var absX:Number = Math.abs(localP.x);			var absY:Number = Math.abs(localP.y);			if(absX < capsule.x && absY < capsule.y) {				//origin = V2.fromP(Util.localizePoint(world, this, new Point(localP.x, localP.y + 10))).divideN(world.scale);				return v;			}			else {				var rectP:Point;				/// Quick hack to reduce gravity jitter close to the capsule boundary.				if(absX < capsule.x) {					if(localP.y > 0) {						return v.clone().multiplyN(-1);					}					else {						return v.clone();					}					//rectP = new Point(localP.x, 0);					//localP.y += (localP.y > 0 ? 1000 : -1000);				}				else if(absY < capsule.y) {					if(localP.x > 0) {						return v.clone().ccw90();					}					else {						return v.clone().cw90();					}					//rectP = new Point(0, localP.y);					//localP.x += (localP.x > 0 ? 1000 : -1000);				}				else {					/// Find the closest point on the rectangle.					rectP = new Point(Math.min(capsule.x, Math.abs(localP.x)), Math.min(capsule.y, Math.abs(localP.y)));					rectP.x *= (localP.x > 0 ? 1 : -1);					rectP.y *= (localP.y > 0 ? 1 : -1);				}				/// Convert that point into the b2 world coordinate space.				origin = V2.fromP(Util.localizePoint(world, this, rectP)).divideN(world.scale);			}			/// Calculate radial gravity from that point.			var g:V2 = super.gravity(p, b, b2);			return g;		}	}}